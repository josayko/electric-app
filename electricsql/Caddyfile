# ensures that the jwtauth module runs before the basicauth module
{
	order jwtauth before basicauth
}

# Replace localhost with your domain name in production with the correct HTTPS port
{$PROXY_HOST:"localhost"}:{$PROXY_PORT:8443} {
	tls internal # Remove this line in production

	# Handle OPTIONS requests first
	@cors_preflight method OPTIONS
	respond @cors_preflight 204

	# CORS headers
	header Access-Control-Allow-Origin {$CORS_ORIGIN:"http://localhost:5173"}
	header Access-Control-Allow-Methods "GET, HEAD, DELETE, OPTIONS"
	header Access-Control-Allow-Headers "Authorization"

	# Apply JWT auth to non-OPTIONS requests
	@not_options {
		not method OPTIONS
	}
	jwtauth @not_options {
		# You can sign and validate JWT tokens however you prefer. Here we
		# expect tokens to have been signed with the `HS256` algorithm and
		# a shared symmetric signing key to match the configuration in
		# `../server/api/gatekeeper.[table].get.ts`, so that this example config validates
		# tokens generated by the gatekeeper service.
		#
		# Note that the signing key should be base64 encoded:
		#
		#     sign_key "<secret_key_bytes_in_base64_format>"
		#
		# See https://caddyserver.com/docs/modules/http.authentication.providers.jwt
		sign_key {$AUTH_SECRET_BASE64:"TkZMNSowQmMjOVU2RUB0bm1DJkU3U1VONkd3SGZMbVk="}
		sign_alg HS256

		# The jwtauth module requires a user claim but we don't actually use
		# it here, so we just set it to the token issuer.
		user_claims iss

		# Extract the shape definition from the JWT `shape` claim and write
		# into {http.auth.user.*} variables, so e.g.: the `shape.table`
		# becomes {http.auth.user.table} and is used below to match against
		# the request parameters.
		meta_claims \
 "shape.namespace -> namespace" \
 "shape.table -> table" \
 "shape.where -> where" \
 "shape.columns -> columns"
	}

	# Match `GET /v1/shape` requests.
	@get_shape {
		method GET

		path /v1/shape
	}

	# Match requests whose JWT shape definition matches the shape definition
	# in the request parameters.
	#
	# So, for example, a claim of `{"shape": {"table": "items"}}` will match
	# a query parameter of `?table=items`.
	#
	# Note that the first part of the expression matches the request table
	# param against either the shape `table` or `namespace.table` depending
	# on whether the shape `namespace` is empty or not.
	@definition_matches {
		expression <<CEL
      (
        {http.auth.user.namespace} == ""
        ? {http.auth.user.table} == {http.request.uri.query.table}
        : {http.auth.user.namespace} + "." + {http.auth.user.table} == {http.request.uri.query.table}
      )
      && {http.auth.user.where} == {http.request.uri.query.where}
      && {http.auth.user.columns} == {http.request.uri.query.columns}
    CEL
	}

	# Route the request according to the matchers.
	handle @get_shape {
		handle @definition_matches {
			# This rewrite modifies the URI sent to the upstream service
			rewrite * "{http.request.uri.path}?{http.request.uri.query}&secret={$ELECTRIC_SECRET:secret}"
			reverse_proxy {$ELECTRIC_URL:"http://electric:3000"} {
				# Remove CORS headers from backend to prevent conflicts
				header_down -Access-Control-Allow-Origin
				header_down -Access-Control-Allow-Methods
			}
		}

		respond "Forbidden" 403 {
			close
		}
	}

	respond "Not found" 404 {
		close
	}
}
